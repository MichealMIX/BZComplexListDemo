# BZComplexListDemo

## 2020.7.8

**master**版本构建完毕类似微博首页列表，完全原生方法处理，图片加载，tableview的绘制全部采用原生方法

性能测试：

测试工具：instrument 

**`GPU FPS`**：测试得到 GPU fps基本没有超过30的时候

**`Time Profile`**:Time Profile测试经过6秒才正常启动，耗时全部在主线程上，总共运行了30秒，主线程耗时6秒。滑动十分卡顿。

**`CPU Usage`**:因为并未使用GCD等手段因此CPU使用率还算正常。

**`CPU FPS`**:CPU的fps检测也十分卡顿基本维持在20以下，长时间甚至是5以下，说明主线程中发生大量耗时操作。

详情见测试文件

## 2020.7.9

开始优化之前先搞清楚成像原理以及可能造成卡顿的原因

**成像原理**

显示器的成像原理就是由电子枪一行一行的从上到下一行行扫描，扫描完成后显示器就会显示这一帧画面，随后电子枪回到初始位置进行下一帧的扫描。

为了把显示器的显示过程和系统的视频控制器进行同步，显示器会用硬件时钟产生一系列的定时信号，当电子枪准备新的一行扫描时，显示器会发出一个水平同步信号，HSync。当电子枪绘制完一帧之后回到原位准备下一帧的绘制时会发出一个垂直同步信号VSync。显示器通常以固定的频率进行刷新，这个刷新频率就是VSync产生的频率。

我们电脑中的显示流程通常是这样的，CPU计算好显示内容提交到GPU，GPU渲染完毕后将结果放入帧缓冲区，随后视频控制器会按照VSync信号逐行读取帧缓冲区中的内容，然后经过数模转换传递给显示器。

现在的显示原理都是采用双缓冲机制来进行渲染，GPU会预先渲染好一帧放在一个缓冲区内，让视频控制器读取，然后下一帧渲染好之后，直接把视频控制器的指针指向第二个缓冲区，效率得到极大提升，但是这样做会有一个问题，就是当第一帧还没完全显示完毕的时候，指针指向了第二个缓冲区，就会造成画面撕裂现象。为了解决这个问题GPU也有一个同步机制，垂直同步也叫V-Sync，GPU会等待显示器的垂直同步信号，才进行新一帧画面的渲染。但会消耗更多计算资源。

iOS是采用双缓存+垂直同步开启的机制。

在VSync信号来临时，系统图形服务会通过CADisplayLink等机制通知APP，APP主线程开始在CPU中计算内容，比如视图的创建，布局计算，图片解码，文本绘制。随后CPU会将计算好的内容交给GPU，GPU进行变换，合成，渲染。之后GPU会把渲染好的内容提交到缓冲区中，下一次VSync到来时会显示到屏幕上。由于垂直同步的机制，下一次信号到来之前如果CPU或者GPU没有工作完毕，那么这一帧就会丢弃，也就是我们看到的卡顿，所以APP卡顿和CPU和GPU都有关系。

今天先从最简单的开始入手，对象的创建，CALayer是比UIView更轻量级的视图控件，但是它不能独立响应事件，今天的目的就是将文字Label，图片，使用Layer进行替换，先不考虑触摸事件。

## 2020.7.17

已经全部更新完毕，calayer替换了imageView，但是肉眼效果并不明显，而且计算过程复杂繁琐。中间涉及多线程队列组，加锁解锁操作。还有缓存的写入读取操作。

**`GPU FPS`**：测试得到 GPU fps偶尔会达到40-50，但是观感还是很卡顿

**`Time Profile`**:Time Profile测试经过10秒才正常启动，看得出耗时还是在主线程上。

**`CPU Usage`**:CPU使用率也有所升高。

**`CPU FPS`**:CPU的fps检测也十分卡顿基本维持在20以下，长时间甚至是5以下，说明主线程中发生大量耗时操作。

经历了把view换为layer提升效果并不明显
